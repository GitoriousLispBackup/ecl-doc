<?xml version="1.0" encoding="utf-8"?><!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book lang="en">
<chapter id="ext.asdf">
 <title>ASDF</title>

 <section id="ext.asdf.sdf">
  <title>System definition files</title>

  <para>A System Definition File or <emphasis>system</emphasis>, is the lisp
  equivalent of a makefile in the Unix world: it contains a list of source
  files which are to be loaded or compiled, and dependencies among them ("load
  source <filename>file1.lsp</filename> before compiling
  <filename>file2.lsp</filename>", etc).</para>

  <para>I cannot tell about the Lisp Machines history, but until recently, the
  most popular system definition format was called
  <application>mk-defsystem</application> or simply
  <application>defsystem</application>. A simple definition might look as
  follows:</para>
<programlisting>
(defsystem test
  :source-pathname "~/src/test/"
  :source-extension "lisp"
  :components ((:module file1
                        :source-pathname "")
               (:module file2
                        :source-pathname ""
                        :depends-on (file1))))</programlisting>
  <para>This example consists of two files, <filename>file1.lisp</filename> and
  <filename>file2.lisp</filename>, located in
  <filename>~/src/test/</filename>. When compiling these files,
  <filename>file1.lisp</filename> will be processed before
  <filename>file2.lisp</filename>, because the second depends on the former
  one.</para>

  <para>Written by Mark Kantrowitz [<xref linkend="bib.mk-defsystem"/>], this
  library now lives in the <ulink
  url="https://sourceforge.net/projects/clocc/">CLOCC</ulink> repository and is
  actively maintained. &ECL; ships with a copy of the version 3.x which
  fortunately has no customizations. You can load this copy by issuing
  <code>(require 'defsystem)</code> from the lisp toplevel.</para>

  <para>In the last years, Another System Definition Facility known as &ASDF;
  has become more popular in the &CommonLisp; world. This new format simplifies
  writing extensions to handle new kind of source files and integrates very
  well with the package management utility known as
  <application>ASDF-install</application>. &ASDF; has a slightly different
  syntax from <application>mk-defsystem 3.0</application>. To learn how to use
  it we recommend reading the <ulink
  url="http://constantly.at/lisp/asdf/">online manual</ulink>.</para>

  <para>&ASDF; is shipped with various implementations of &CommonLisp; such as
  &SBCL; &OpenMCL; and &ECL; itself. In all these cases, using <code>(require
  'asdf)</code> will suffice to load the library and extend the system function
  <function>require</function> with tools to handle &ASDF; modules.</para>

  <para>In the case of &ECL;, &ASDF; has been further customized to allow
  building standalone &FASL; files and executable programs up from one or more
  definition files. The procedure to do this is documented in <xref
  linkend="ext.asdf.make-build"/> and in the manual page for <xref
  linkend="ref.make-build"/>.</para>
 </section>

 <section id="ext.asdf.make-build">
  <title>Block building</title>

  <para></para>
 </section>

 <section id="ext.asdf.dict">
  <title>ASDF Reference</title>

<!-- ====================================================================== -->
<!-- ASDF:MAKE-BUILD                                                        -->
<!-- ====================================================================== -->

  <refentry id="ref.make-build">
   <refnamediv>
    <refname><function>asdf:make-build</function></refname>
    <refpurpose>Block-build an &ASDF; system definition</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
    <title>Function</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>asdf:make-build</funcdef>
      <paramdef>&key;</paramdef>
      <paramdef><parameter>type</parameter></paramdef>
      <paramdef><parameter>args</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <variablelist>
     <varlistentry>
      <term><replaceable>type</replaceable></term>
      <listitem><para>One of <symbol>:FASL</symbol>, <symbol>:DLL</symbol>,
      <symbol>:SHARED-LIBRARY</symbol> or
      <symbol>:PROGRAM</symbol></para></listitem>
     </varlistentry>
     <varlistentry>
      <term><replaceable>args</replaceable></term>
      <listitem><para>A list of additional keyword arguments that are passed to
      <function>c:builder</function>.</para></listitem>
     </varlistentry>
    </variablelist>
   </refsynopsisdiv>

   <refsect1>
    <title>Description</title>

    <para>The function works similar to <function>asdf:oos</function> with the
    <function>asdf:load-op</function> operator. However, instead of producing
    multiple compiled files, it generates a single file, which is either a
    &FASL;, a shared library or a standalone program, depending on
    <replaceable>type</replaceable>.</para>

    <para>The protocol of this operator is as follows</para>
    <procedure>
     <step><para>Examine the list of sources and their dependencies.</para></step>
     <step><para>For each source</para>
     <substeps>
      <step><para>Load all prerequisite sources (uncompiled).</para></step>
      <step><para>Compile the file with
      <replaceable>SYSTEM-P</replaceable> &t;</para></step>
     </substeps></step>
     <step><para>Combine all files using <function>c:build-fasl</function>,
     <function>c:build-shared-library</function>,
     <function>c:build-static-library</function> or
     <function>c:build-program</function>.</para></step>
    </procedure>
   </refsect1>

   <refsect1>
    <title>Examples</title>

    <para>In <filename>/ecl/examples/asdf</filename> you will find a very
    simple example that can be built in different forms. The example is built
    around a system definition file that depends on two sources,
    <filename>file1.lisp</filename> and <filename>file2.lisp</filename>:</para>
    <programlisting>
(defsystem #:example
    :serial t
    :components ((:file "file1")
		 (:file "file2")))</programlisting>

    <para>We can built these files into a single &FASL; file, as shown
    below. Notice how there is a single file with the name
    <filename>*.fas</filename>, but there are two object files generated from
    their respective sources, <filename>file1.o</filename>,
    <filename>file2.o</filename>.</para>
<screen>
&gt; (require 'asdf)
;;; Loading #P"/home/jlr/lib/ecl/asdf.fas"
("ASDF")
&gt; (asdf:make-build :example :type :fasl)
...
NIL
&gt; (directory "*.o")
(#P"/home/jlr/src/ecls-new/examples/asdf/file2.o"
 #P"/home/jlr/src/ecls-new/examples/asdf/file1.o")
&gt; (directory "*.fas")
(#P"/home/jlr/src/ecls-new/examples/asdf/example.fas")
&gt; (load "example.fas")
;;; Loading "/home/jlr/src/ecls-new/examples/asdf/example.fas"
======================================================================
We are now executing FILE1.LSP
TEST-FUNCTION has been created
We are now executing FILE2.LSP
Calling TEST-FUNCTION in FILE2.LSP
1 + 1 is equal to 2
Finished
======================================================================
"/home/jlr/src/ecls-new/examples/asdf/example.fas"
</screen>

    <para>The previous sources may be combined into a single program, as shown
    below. Notice that we choose to execute <function>ext:quit</function> right
    after all compiled files have run. If you do not supply this parameter,
    <filename>example</filename> will jump to the lisp toplevel right after
    that.</para>
<screen>
&gt; (asdf:make-build :example :type :program
                   :args (list :epilogue-code '(ext:quit 0)))
NIL
&gt; (ext:system "./example")
======================================================================
We are now executing FILE1.LSP
TEST-FUNCTION has been created
We are now executing FILE2.LSP
Calling TEST-FUNCTION in FILE2.LSP
1 + 1 is equal to 2
Finished
======================================================================</screen>
   </refsect1>
  </refentry>

 </section>
 </chapter>
</book>
<!-- Keep this comment at the end of the file
      Local variables:
      mode: nxml
      sgml-parent-document: "ecl.xml"
      sgml-indent-step: 1
      nxml-child-indent: 1
      nxml-outline-child-indent: 1
      fill-column: 79
      End:
 -->