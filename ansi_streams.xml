<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book [
<!ENTITY % eclent SYSTEM "ecl.ent">
%eclent;
]>
<book xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en">
<chapter xml:id="ansi.streams">
 <title>Streams</title>

 <section xml:id="ansi.streams.types">
  <title>Stream types</title>

  <para>&ECL; implements all stream types described in &ANSI;. Additionally,
  when configured with option <option>--enable-clos-streams</option>, &ECL;
  includes a version of Gray streams where any object that implements the
  appropiate methods (<function>stream-input-p</function>,
  <function>stream-read-char</function>, etc) is a valid argument for the
  functions that expect streams, such as <function>read</function>,
  <function>print</function>, etc.</para>

 </section>

 <section xml:id="ansi.streams.io">
  <title>Input/Output model</title>

  <para>&ECL; distinguishes between two kinds of streams: character streams
  and byte streams. In the first kind one is only allowed to write
  characters, either individually, with <function>write-char</function>, or
  in chunks, with <function>write-sequence</function> or any of the Lisp
  printer functions. The implementation of character streams in &ECL; has the
  following shortcomings:
  <itemizedlist>
   <listitem><para>No support for external formats. Reading and writing is
   performed using the 8-bit code of the character.</para></listitem>
   <listitem><para>No support for Unicode characters. The code of large
   characters is simply truncated.</para></listitem>
  </itemizedlist></para>

  <para>The other kind are binary streams. Here input and output is performed
  in chunks of bits. Binary streams are created with the function
  <function>open</function> passing as argument a subtype of
  <type>integer</type>. We distinguish two cases
  <itemizedlist>
   <listitem><para>The word size is a multiple of 8 bits: element types
   <type>(byte 8)</type>, <type>(signed-byte 32)</type>,
   etc.</para></listitem>
   <listitem><para>The word size is not a multiple of 8 bits: element types
   <type>(unsigned-byte 3)</type>, <type>(signed-byte 15)</type>,
   etc.</para></listitem>
  </itemizedlist>
  In the first case the length of the file can be deduced from the number of
  octets which are used in the filesystem. In the second case, however, one
  needs some extra information which tells how many bits in the last byte are
  significant for the content. This information is stored as a single-byte
  header at the beginning of the file.</para>
 </section>

 <xi:include href="ref_c_streams.xml" xpointer="ansi.streams.c-dict" xmlns:xi="http://www.w3.org/2001/XInclude"/>

</chapter>
</book>